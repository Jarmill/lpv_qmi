classdef lpvstab
    %LPVSTAB stabilizing control of LPV systems using QMIs    
    
    %in experiments, stick with individual sample noise bounds.
    %until otherwise implemented
    
    properties
        
        %start traj with only one trajectory, then expand to multiple
        traj; %trajectory trace
        
        Psi; %data matrix 
        Psi_E; %data matrix with zero padding
        
        vars;
        
        delta = 1e-5; %tolerance for being positive (positive definite)
       
        
        opts = sdpsettings('solver', 'mosek');
    end
    
    methods
        function obj = lpvstab(traj)
            %LPVSTAB Construct an instance of this class
            %   Detailed explanation goes here
%             obj.Property1 = inputArg1 + inputArg2;
            obj.traj = traj;
            
            obj.Psi = sample_matrix(traj.X, traj.U, traj.epsilon, traj.Th);
            
            obj.Psi_E = blkdiag(Psi, zeros(obj.traj.m));            
        end
        
        function [cons, vars] = make_program(obj, Th_vert)
            %MAKE_PROGRAM form the LMI program in YALMIP
            
            %Th_vert: vertices of parameter region
                                  
            Y = sdpvar(n, n);

            %storage of variables
            vars = struct;
            vars.Y = Y;
            vars.M = cell(Nv, 1);
            vars.Cv = cell(Nv, 1);
            vars.a = zeros(Nv, 1, 'like', sdpvar);
            vars.b = zeros(Nv, 1, 'like', sdpvar);
            
            %storage of constraints
            cons = (Y >= eye(obj.traj.n)*obj.delta);
            %iterate through each subsystem and generate QMI
            for v = 1:Nv
                thv = Th_vert(:, v);
                
                [cons_vert, vars_vert] = obj.vertex_qmi(Y, thv);
                
                cons = [cons; cons_vert];
                vars.a(v) = vars_vert.a;
                vars.b(v) = vars_vert.b;
                vars.M{v} = vars_vert.M;                
                vars.Cv{v} = vars_vert.M;
            end
            
        end
        
        function [out] = solve_program(obj, cons, vars)
            %run the program
            sol = optimize(cons, 0, obj.opts);
            out.sol = sol;
            
            if sol.status==0
                %successful trajectory execution
                out = obj.recover(vars);
            end
        end
        
        function [out] = stab(
        
        function [cons_vert, vars_vert] = obj.vertex_qmi(obj, Y, thv);
            %VERTEX_QMI: find the QMI associated with subsystem stabilization
            %at the parameter vertex thv
            
            %find sizes
            n = obj.traj.n;
            m = obj.traj.m;
            L = size(thv, 1);
            
            %declare variables
            M = sdpvar(m, n, 'full'); %K = (Y \ M')'
            a = sdpvar(1,1);
            b = sdpvar(1,1);
            
            v2Y = kron(thv*thv', Y);
            vM = kron(thv, M');
            
            %form the controller matrix
            CT_bot = [-v2Y, -vM, zeros(L*n, n);
                      -vM', zeros(m, m), M;
                      zeros(n, L*n), M', Y];
                  
            CT = blkdiag(Y-b*eye(n), CT_bot);
            CV = CT - alpha*obj.Psi_E;
            
%             sCT = size(sCT, 1); %should be (L+2)n + m
            cons_vert = [CV >= 0; a >= 0; b>=obj.delta];
            vars_vert = struct('M', M, 'a', a, 'b', b, 'CS', CV);
        end
        
        
    end
end

